name: Build Desktop Self Host - AIO
on:
  workflow_dispatch: {}
    
env:
  CARGO_TERM_COLOR: always
  WORKSPACE_PATH: ${{ github.workspace }}
  WEB_PATH: ${{ github.workspace }}/packages/hoppscotch-selfhost-web
  DESKTOP_PATH: ${{ github.workspace }}/packages/hoppscotch-desktop
  BUNDLER_PATH: ${{ github.workspace }}/packages/hoppscotch-desktop/crates/webapp-bundler
  PROJECT_PATH: packages/hoppscotch-selfhost-desktop
  MSI_GLOB: packages/hoppscotch-selfhost-desktop/src-tauri/target/release/bundle/msi/*.msi
  TIMESTAMP_URL: ${{ secrets.TIMESTAMP_URL || 'http://timestamp.digicert.com' }}
jobs:
  build-windows:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v3
      
      - uses: actions/setup-node@v3
        with:
          node-version: 20
          
      - uses: pnpm/action-setup@v4

      - uses: actions-rs/toolchain@v1
        with:
          toolchain: nightly
          override: true
      
      - name: Setting up Windows Signing Environment
        timeout-minutes: 20
        shell: pwsh
        run: |
          $pfxBytes = [Convert]::FromBase64String("${{ secrets.CERT_PFX_B64 }}")
          $pfxPath  = "$env:RUNNER_TEMP\codesign.pfx"
          [IO.File]::WriteAllBytes($pfxPath, $pfxBytes)
          Write-Host "PFX restored to $pfxPath"
          
      - uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          
      - name: Setup environment
        shell: pwsh
        run: |
          if ("${{ secrets.ENV_FILE_CONTENT }}" -ne "") {
            "${{ secrets.ENV_FILE_CONTENT }}" | Out-File -FilePath ${{ env.WORKSPACE_PATH }}\.env -Encoding utf8
            Write-Host "Created .env file from repository secret"
          } elseif (Test-Path -Path "${{ env.WORKSPACE_PATH }}\.env") {
            Write-Host "Using existing .env file found in repository"
          } else {
            Copy-Item ${{ env.WORKSPACE_PATH }}\.env.example ${{ env.WORKSPACE_PATH }}\.env
            Write-Host "No .env found, copied from .env.example template"
          }
          pnpm install -f --shamefully-hoist --ignore-scripts
          pnpm --filter hoppscotch-backend exec prisma generate
          pnpm install -f --shamefully-hoist --dir ${{ env.DESKTOP_PATH }}
      - name: Build web app
        shell: pwsh
        run: |
          pnpm install --dir ${{ env.WEB_PATH }}
          pnpm --dir ${{ env.WEB_PATH }} generate
      - name: Build and run webapp-bundler
        shell: pwsh
        run: |
          cargo build --release --manifest-path ${{ env.BUNDLER_PATH }}\Cargo.toml
          ${{ env.BUNDLER_PATH }}\target\release\webapp-bundler.exe `
            --input ${{ env.WEB_PATH }}\dist `
            --output ${{ env.DESKTOP_PATH }}\bundle.zip `
            --manifest ${{ env.DESKTOP_PATH }}\manifest.json
      - name: Build Tauri app without Azure signing
        shell: powershell
        env:
          RUST_LOG: debug
        run: pnpm --dir ${{ env.DESKTOP_PATH }} tauri build --verbose -b msi -b updater
        
      - name: Locate MSI(s)
        id: findmsi
        shell: pwsh
        run: |
          $files = Get-ChildItem "${{ env.MSI_GLOB }}"
          if (-not $files) { throw "No MSI files found at $env:MSI_GLOB" }
          $list = $files | ForEach-Object { $_.FullName } | Join-String -Separator "`n"
          "msi_list<<EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          $list | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "Found:`n$list"

      - name: Sign MSI(s)
        shell: pwsh
        run: |
          $pfxPath = "$env:RUNNER_TEMP\codesign.pfx"
          $password = "${{ secrets.CERT_PASSWORD }}"
          $timestamp = "${{ env.TIMESTAMP_URL }}"
          $files = @()
          $lines = @'
          ${{ steps.findmsi.outputs.msi_list }}
          '@.Trim().Split("`n") | ForEach-Object { $_.Trim() } | Where-Object { $_ }
          $files = $lines

          foreach ($f in $files) {
            Write-Host "Signing $f"
            & "C:\Program Files (x86)\Windows Kits\10\bin\x64\signtool.exe" sign `
              /fd sha256 `
              /f "$pfxPath" /p "$password" `
              /tr "$timestamp" /td sha256 `
              "$f"
            if ($LASTEXITCODE -ne 0) { throw "signtool sign failed for $f" }
          }

      - name: Verify signatures
        shell: pwsh
        run: |
          $files = @()
          $lines = @'
          ${{ steps.findmsi.outputs.msi_list }}
          '@.Trim().Split("`n") | ForEach-Object { $_.Trim() } | Where-Object { $_ }
          $files = $lines

          foreach ($f in $files) {
            Write-Host "Verifying $f"
            & "C:\Program Files (x86)\Windows Kits\10\bin\x64\signtool.exe" verify /pa /v "$f"
            if ($LASTEXITCODE -ne 0) { throw "signtool verify failed for $f" }
          }

      - name: Securely remove PFX
        if: always()
        shell: pwsh
        run: |
          $pfxPath = "$env:RUNNER_TEMP\codesign.pfx"
          if (Test-Path $pfxPath) {
            Remove-Item -Path $pfxPath -Force
          }

      - name: Upload signed MSI
        uses: actions/upload-artifact@v4
        with:
          name: hoppscotch-desktop-msi-signed
          path: ${{ env.MSI_GLOB }}
  
